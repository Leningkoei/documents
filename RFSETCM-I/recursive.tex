\documentclass[11pt, a4paper]{article}

\usepackage{type1cm}
\usepackage{amsfonts, amssymb, amsmath}
\usepackage{enumerate} % import for the form like line 643

\usepackage{hyperref}

\title{Recursive Functions of Symbolic Expressions and Their Computation by
  Machine, Part I}
\author{John McCarthy}
\date{April 1960}

\begin{document}

\pagenumbering{alph}
\maketitle
\thispagestyle{empty}
\pagebreak

\pagenumbering{roman}
\tableofcontents
\pagebreak
\pagenumbering{arabic}

\section{Introduction}

A programming system called LISP (for LISt Processor) has been developed for the
IBM 704 computer by the Artificial Intelligence group at M.I.T. The system was
designed to
facilitate\footnote{facilitate: $verb$ \textit{facilitate something} (formal) to
  make an action or a process possible or easier.}
experiments with a proposed system called the Advice
Taker,
whereby\footnote{whereby: $adv.$ (formal) by which, because of which.}
a machine could be instructed to handle declarative as well as
imperative\footnote{imperative: $adj.$ [not usually before noun] (formal) very
  important and needing immediate attention or action. $syn$ vital}
sentences and could
exhibit\footnote{exhibit$^*$: $verb$ to show something in a public place for
  people to enjoy or to give them information.}
``common sense'' in carrying out its
instructions. The original
proposal\footnote{proposal$^*$: $noun$ a formal suggestion or plan; the act of
  making a suggestion.}
for the Advice Taker was made in November
1958. The main requirement was a programming system for
manipulating\footnote{manipulate: $verb$ (disapproving) to control or influence
  somebody/something, often in a dishonest way so that they do not realize
  it. --- dishonest: $adj.$ not honest; intending to trick people.}
expressions
representing formalized declarative and imperative sentences so that the Advice
Taker system could make
deductions\footnote{deduction: $noun$ the process of using information you have
  in order to understand a particular situation or to find the answer to a
  problem.}
.

In the course of its development the LISP system went through several stages of
simplification\footnote{simplification: $noun$ the process of making something
  easier to do or understand.}
and eventually came to be based on a scheme for representing the
partial\footnote{partial: $adj.$ not complete or whole.}
recursive functions of a certain class of symbolic expressions. This
representation is independent of the IBM 704 computer, or of any other
electronic computer, and it now seems
expedient\footnote{expedient: $noun$ an action that is useful or necessary for a
  particular purpose, but not always fair or right. $adj.$ [not usually before
    noun] (of an action) useful or necessary for a particular purpose, but not
  always fair or right.}
to
expound\footnote{expound: $verb$ (formal) to explain something by talking about
  it in detail.}
the system by
starting with the class of expressions called S-expressions and the functions
called S-functions.

In this article, we first describe a
formalism\footnote{formalism: $noun$ a style or method in art, music,
  literature, science, etc. that pays more attention to the rules and the
  correct arrangement and appearance of things than to inner meaning and
  feelings. --- arrangement: $noun$ a plan or preparation that you make so that
  something can happen. --- appearance: $noun$ the way that somebody/something
  looks on the outside; what somebody/something seems to be.}
for defining functions
recursively. We believe this formalism has advantages both as a programming
language and as a vehicle for developing a theory of computation. Next, we
describe S-expressions and S-functions, give some examples, and then describe
the universal S-function $apply$ which plays the theoretical role of a universal
Turing machine and the practical role of an interpreter. Then we describe the
representation of S-expressions in the memory of the IBM 704 by list structures
similar to those used by Newell, Shaw and Simon, and the representation of
S-functions by program. Then we mention the main features of the LISP
programming system for the IBM 704. Next comes another way of describing
computations with symbolic expressions, and finally we give a recursive function
interpretation of flow charts.

We hope to describe some of the symbolic computations for which LISP has been
used in another paper, and also to give
elsewhere\footnote{elsewhere$^*$: $adv.$ in, at or to another place.}
some applications of our
recursive function formalism to mathematical logic and to the problem of
mechanical theorem proving.

\section{Functions and Function Definitions}

We shell need a number of mathematical ideas and notations
concerning\footnote{concerning$^*$: $prep.$ (formal) about something; involving
  somebody or something. involve: $verb$ if a situation, an event or an activity
  involves something, that thing is an important or necessary part or result of
  it. $syn$ entail}
functions
in general. Most of the ideas are well known, but the notation of conditional
expression is believed to be new, and the use of conditional expressions
permits\footnote{permit$^*$: $verb$ (formal) to allow somebody to do something
  or to allow something to happen.}
functions to be defined recursively in a new and
convenient\footnote{convenient$^*$: $adj.$ \textit{convenient (for
    somebody/something)} useful, easy or quick to do; not causing problems.}
way.

\paragraph{a.}\textit{Partial Functions.}
A partial function is a function that is defined only on part of its
domain. Partial functions necessarily arise when functions are defined by
computations because for some values of the arguments the computation defining
the value of the function may not
terminate\footnote{terminate: $verb$ (formal) to end; to make something end.}
. However, some of our
elementary\footnote{elementary: $adj.$ in or connected with the first stages of
  a course of study.}
functions will be defined as partial functions.

\paragraph{b.}\textit{Propositional Expressions and Predicates.}
A
propositional\footnote{proposition: $noun$ an idea or a plan of action that is
  suggested, especially in business.}
expression is an expression whose possible values are $T$ (for
truth) and F (for falsity). We shall
assume\footnote{assume$^*$: $verb$ to think or accept that something is true but
  without having proof of it.}
that the reader is familiar with the
propositional connectives $\land$ (``and''), $\lor$ (``or''), and $\lnot$
(``not''). Typical propositional expressions are:
$$ x < y $$
$$ (x < y) \land (b = c)  $$
\begin{center}$x$ is prime\end{center}

A
predicate\footnote{predicate: $noun$ (grammar) a part of a sentence containing a
  verb that makes a statement about the subject of verb, such as $went \ home$
  in $John \ went \ home$.}
is a function whose range
consists\footnote{consist$^*$: $verb$ (not used in the progressive tenses)
  \textit{consist in something} (formal) to have something as the main or only
  part or feature. \textit{consist of somebody/something} to be formed from the
  thing or people mentioned.}
of the truth values $T$ or $F$.

\paragraph{c.}\textit{Conditional Expressions.}

The dependence of truth value on the values of quantities of other kinds is
expressed in mathematics by predicates, and the dependence of truth values on
other truth values by logical connectives. However, the notations for expressing
symbolically the dependence of quantities of other kinds on truth values is
inadequate, so that English words and phrases are generally used for expressing
these dependences in texts that describe other dependences symbolically. For
example, the function $|x|$ is usually defined in words. Conditional expressions
are a device for expressing the dependence of quantities on propositional
quantities. A conditional expression has the form
$$ (p_1 \to e_1, \ldots p_n \to e_n)  $$
where the $p$'s are propositional expressions and the $e$'s are expressions of
any kind. It may be read, ``If $p_1$ then $e_1$ otherwise if $p_2$ then $e_2$,
$\ldots$, otherwise if $p_n$ then $e_n$'', or ``$p_1$
yields\footnote{yield: $verb$ \textit{yield something} to produce or provide
  something, for example a profit, result or crop.}
$e_1$, $\ldots$,
$p_n$ yields $e_n$''.

We now give the rules for
determining\footnote{determine$^*$: $verb$ (formal) to discover the facts about
  something; to calculate something exactly.}
whether the value of
$$ (p_1 \to e_1, \ldots, p_n \to e_n) $$
is defined, and if so what its value is. Examine the $p$'s from left to
right. If a $p$ whose value is $T$ is
encountered\footnote{encounter$^*$: $verb$ \textit{encounter something} to
  experience something, especially something unpleasant or difficult, while you
  are trying to do something else.}
before any $p$ whose value is
undefined is encountered then the value of the conditional expression is the
value of the
corresponding\footnote{corresponding: $adj.$ matching or connected with
  something that you have just mentioned. $syn$ equivalent}
$e$ (if this is defined). If any undefined $p$ is
encountered before a true $p$, or if all $p$'s are false, or if the $e$
corresponding to the first true $p$ is undefined, then the value of the
conditional expression is undefined. We now give examples.
$$ (1 < 2 \to 4, 1 > 2 \to 3) = 4 $$
$$ (2 < 1 \to 4, 2 > 1 \to 3, 2 > 1 \to 2) = 3 $$
$$ (2 < 1 \to 4, T \to 3) = 3 $$
$$ (2 < 1 \to \frac{0}{0}, T \to 3) = 3 $$
\begin{center}$ (2 < 1 \to 3, T \to \displaystyle\frac{0}{0}) $
  is undefined\end{center}
\begin{center}$ (2 < 1 \to 3, 4 < 1 \to 4) $ is
  undefined\end{center}


Some of the simplest applications of conditional expressions are in giving such
definitions as
$$ |x| = (x < 0 \to -x, T \to x) $$
$$ \delta_{ij} = (i = j \to 1, T \to 0) $$
$$ sgn(x) = (x < 0 \to -1, x = 0 \to 0, T \to 1) $$

\paragraph{d.}\textit{Recursive Function Definitions.}
By using conditional expressions we can, without circularity, define functions
by formulas in which the defined function occurs. For example, we write
$$ n! = (n = 0 \to 1, T \to n \cdot (n - 1)!) $$
When we use this formula to evaluate $0!$ we get the answer 1; because of the
way in which the value of a conditional expression was defined, the meaningless
expression $0 \cdot (0 - 1)!$ does not arise. The evaluation of $2!$ according
to this definition
proceeds\footnote{proceed$^*$: $verb$ \textit{proceed (with something)} to
  continue doing something that has already been started; to continue being
  done.}
as follows:
\begin{align*}
  2! &= (2 = 0 \to 1, T \to 2 \cdot (2 - 1)!) \\
     &= 2 \cdot 1!                                            \\
     &= 2 \cdot (1 = 0 \to 1, T \to 1 \cdot (1 - 1)!) \\
     &= 2 \cdot 1 \cdot 0!                                    \\
     &= 2 \cdot 1 \cdot (0 = 0 \to 1, T \to 0 \cdot (0 - 1)!) \\
     &= 2 \cdot 1 \cdot 1                                     \\
     &= 2
\end{align*}

We now give two other applications of recursive function definitions. The
greatest common divisor, $gcd(m, n)$, of two positive integers $m$ and $n$ is
computed by means of the Euclidean algorithm. This algorithm is expressed by the
recursive function definition:
\begin{align*}
  gcd(m, n) = (m > n &\to gcd(n, m), \\
       rem(n, m) = 0 &\to m,         \\
                   T &\to gcd(rem(n, m), m))
\end{align*}
where $rem(n, m)$
denotes\footnote{denote: $verb$ (formal) 1. \textit{denote something
    \text{\textbar} denote that...} to be sign of something. $syn$ indicate;
  2. \textit{denote something \text{\textbar} denote what, when, etc...} to mean
  something. $syn$ represent}
the remainder left when $n$ is divided by $m$.

The Newtonian algorithm for
obtaining\footnote{obtain$^*$: $verb$ (formal) \textit{obtain something} to get
  something, especially by making an effort. --- effort: $noun$ the physical or
  mental energy that you need to do something that take a lot of energy.}
an
approximate\footnote{approximate$^*$: $adj.$ almost correct or accurate, but not
  completely so. $opp$ exact --- accurate: $adj.$ correct and true in every detail.}
square root of a number of
$a$, starting with an initial approximation $x$ and requiring that an acceptable
approximation $y$ satisfy $|y^2 - a| < \epsilon$, may be written as
\begin{align*}
  sqrt(a, x, \epsilon) =
  (|x^2 - a| < \epsilon &\to x, \\
                      T &\to sqrt(a, \frac{1}{2}(x + \frac{a}{x}), \epsilon))
\end{align*}

The
simultaneous\footnote{simultaneous: $adj.$ happening or done at the same time as
  something else.}
recursive definition of several functions is also possible, and
we shell use such definitions if they are required.

There is no
guarantee\footnote{guarantee$^*$: $noun$ a firm promise that you will do
  something or that something will happen. $syn$ assurance --- firm: $adj.$ fairly
  hard; not easy to press into a different shape.}
that the computation determined by a recursive definition
will ever terminate and, for example, an attempt to compute $n!$ from our
definition will only succeed if $n$ is a non-negative integer. If the
computation does not terminate, the function must be
regarded\footnote{regard$^*$: $verb$ 1. to think about somebody/something in
  particular way. 2. \textit{regard somebody/something (+ adv./prep.)} (formal)
  to look at somebody/something, especially in a particular way. $syn$
  contemplate}
as undefined for
given arguments.

The propositional connectives themselves can be defined by conditional
expressions. We write
\begin{align*}
    p \land q &= (p \to q, T \to F) \\
     p \lor q &= (p \to T, T \to q) \\
      \lnot p &= (p \to F, T \to T) \\
  p \supset q &= (p \to q, T \to T)
\end{align*}

It is readily seen that the right-hand sides of the equations have the correct
truth tables. If we consider situations in which $p$ or $q$ may be undefined,
the connectives $\land$ and $\lor$ are seen to be non-commutative. For example
if $p$ is false and $q$ is undefined, we see that according to the definitions
given above $p \land q$ is false, but $q \land p$ is undefined. For our
applications this non-commutativity is desirable, since $p \land q$ is computed
by first computing $p$, and if $p$ is false $q$ is not computed. If the
computation for $p$ does not terminate, we never get around to computing $q$. We
shell use propositional connectives in this sense hereafter.

\paragraph{e.}\textit{Functions and Forms.}
It is usual in mathematics --- outside of mathematical logic --- to use the word
``function''
imprecisely\footnote{imprecise: $adj.$ giving exact details or making something
  clear. $syn$ inaccurate $\leftrightarrow$ $opp$ precise}
and to apply it to forms such as $y^2 + x$. Because we
shall later compute with expressions for functions, we need a
distinction\footnote{distinction: $noun$ \textit{distinction (between A and B)}
  a clear difference or contract especially between people or things that are
  similar or related. --- contrast: $noun$ a difference between two or more
  people or things that you can see clearly when they are compared or put close
  together; the fact of comparing two or more things in order to show
  differences between them.}
between functions and forms and a notation for expressing this distinction. This
distinction and a notation for describing it, from which we
deviate\footnote{deviate: $verb$ \textit{deviate (from something)} to be
  different from something; to do something in a different way from  what is
  usual or excepted.}
trivially\footnote{trivial: $adj.$ not important or serious; not worth
  considering.}
,
is given by Church.

Let $f$ be an expression that stands for a function of two integer variables. It
should make sense to write $f(3, 4)$ and the value of this expression should be
determined. The expression $y^2 + x$ does not meet this requirement; $y^2 + x(3,
4)$ is not a
conventional\footnote{conventional$^*$: $adj.$ (often disapproving) tending to
  follow what is done or considered acceptable by society in general; normal and
  ordinary, and perhaps not very interesting.}
notation, and if we attempted to define it we would be
uncertain whether its value would turn out to be $13$ or $19$. Church calls an
expression like $y^2 + x$, a form. A form can be converted into a function if we
can determine the correspondence between the variables occurring in the form and
the ordered list of arguments of the desired function. This is
accomplished\footnote{accomplished: $adj.$ very good at a particular thing;
  having a lot of skills.}
by
Church's $\lambda$-notation.

If $\mathcal{E}$ is a form in variables $x_1, \ldots, x_n$, then $\lambda((x_1,
\ldots, x_n), \mathcal{E})$ will be taken to be the function of $n$ variables
whose value is determined by
substituting\footnote{substitute$^*$: $verb$ a person or thing that you use or
  have instead of the one you normally use or have. $verb$ to take the place of
  somebody/something else; to use somebody/something instead of
  somebody/something else.}
the arguments for the variables $x_1,
\ldots, x_n$ in that order in $\mathcal{E}$ and evaluating the resulting
expressions. For example, $\lambda((x, y), y^2 + x)$ is a function of two
variables, and $\lambda((x, y), y^2 + x)(3, 4) = 19$.

The variables occurring in the list of variables of a $\lambda$-expression are
dummy\footnote{dummy: $adj.$ (only before noun) made to look real, although it
  is actually a copy which does not work.}
or bound, like variables of
integration\footnote{integration: $noun$ the act or process of combining two or
  more things so that they work together (= of integrating them).}
in a definite
integral\footnote{integral: $adj.$ being an essential part of something.}
. That is,
we may change the names of the bound variables in a function expression without
changing the value of the expression, provided that we make the same change for
each occurrence of the variable and do not make two variables the same that
previously were different. Thus $\lambda((x, y), y^2 + x)$, $\lambda((u, v), v^2
+ u)$ and $\lambda((y, x), x^2 + y)$ denote the same function.

We shall frequently use expressions in which some of the variables are bound
by $\lambda$'s and others are not. Such an expression may be regarded as
defining a function with parameters. The unbound variables are called free
variables.

An
adequate\footnote{adequate: $adj.$ enough in quantity, or good enough in
  quality, for a particular purpose or need.}
notation that distinguishes functions from forms allows an
unambiguous\footnote{unambiguous: $adj.$ clear in meaning; that can only be
  understood in one way.}
treatment of functions of functions. It would involve too much of
digression\footnote{digress: $verb$ (formal) to start to talk about something
  that is not connected with the main point of what you are saying.}
to give examples here, but we shall use functions with functions as
arguments later in this report.

Difficulties arise in combining functions described by $\lambda$-expressions, or
by any other notation involving variables, because different bound variables may
be represented by the same symbol. This is called
collision\footnote{collision: $verb$ \textit{collision (with somebody/something)
    | collision (between/of A and B)} an accident in which two vehicles or
  people crash into each other.}
of bound
variables. There is a notation involving operators that are called combinators
for combining functions without the use of variables. Unfortunately, the
combinatory expressions for interesting combinations of functions tend to be
lengthy and unreadable.

\paragraph{f.}\textit{Expressions for Recursive Functions.}
The $\lambda$-notation is inadequate for naming functions defined
recursively. For example, using $\lambda$'s, we can convert the definition
$$ sqrt(a, x, \epsilon) =
(|x^2 - a| < \epsilon \to x,
T \to sqrt(a, \frac{1}{2}(x + \frac{a}{x}), \epsilon)) $$
into
$$ sqrt = \lambda((a, x, \epsilon),
|x^2 - a| < \epsilon \to x,
T \to sqrt(a, \frac{1}{2}(x + \frac{a}{x}), \epsilon)) $$
,
but the right-hand side cannot serve as an expression for the function because
there would be nothing to
indicate\footnote{indicate$^*$: $verb$ to show that something is true or
  exists.}
that the reference to $sqrt$ within the
expression stood for the expression as a whole.

In order to write expressions for recursive functions, we introduce another
notation. $label(a, \mathcal{E})$ denotes the expression $\mathcal{E}$, provided
that occurrences of $a$ within $\mathcal{E}$ are to be interpreted as referring
to the expression as a whole. Thus we can write
$$ label(sqrt, \lambda((a, x, \epsilon),
                       (|x^2 - a| < \epsilon \to x,
                       T \to sqrt(a, \frac{1}{2}(x + \frac{a}{x}), \epsilon))))
$$
as a name for our sqrt function.

The symbol $a$ in label $(a, \mathcal{E})$ is also bound, that is, it may be
altered systematically without changing the meaning of the expression. It
behaves differently from a variable bound by a $\lambda$, however.

\section{Recursive Functions of Symbolic Expressions}

We shall first define a class of symbolic expressions in terms of ordered pairs
and lists. Then we shall define five elementary functions and predicates, and
build from them by
composition\footnote{composition: $noun$ the different parts which something is
  made of; the way in which the different parts are organized.}
, conditional expressions, and recursive
definitions an
extensive\footnote{extensive$^*$: covering a large area; great in amount.}
class of functions of which we shall give a number of
examples. We shall then show how these functions themselves can be expressed as
symbolic expressions, and we shall define a universal function $apply$ that
allows us to compute from the expression for a given function its value for
given arguments. Finally, we shall define some functions with functions as
arguments and give some useful examples.

\paragraph{a.}\textit{A Class of Symbolic Expressions.}
We shall now define the S-expressions (S stands for symbolic). They are formed
by using the special characters
$$ \cdot $$
$$ ) $$
$$ ( $$
and an infinite set of distinguishable atomic symbols. For atomic symbols, we
shall use strings of capital Latin letters and digits with single
imbedded\footnote{embed: verb. [usually passive] \textit{embed something (in
    something)} to fix something firmly into a substance or solid
  object. \textit{The bullet embedded itself in the wall.}}
blanks. Examples of atomic symbols are
\begin{align*}
&A   \\
&ABA \\
&APPLE \ PIE \ NUMBER \ 3
\end{align*}

There is a
twofold\footnote{twofold: $adj.$ (formal) consisting of two parts.}
reason for departing from the usual mathematical practice of
using single letters for atomic symbols. First, computer programs frequently
require hundreds of distinguishable symbols that must be formed from the 47
characters that are printable by the IBM 704 computer. Second, it is convenient
to allow English words and phrases to stand for atomic entities for
mnemonic\footnote{mnemonic: $noun$ a word, sentence, poem, etc. that helps you
  remember something.}
reason. The symbols are atomic in the sense that any substructure they may have
as sequences of characters is ignored. We assume only that different symbols can
be distinguished. S-expressions are then defined as follows:
\begin{enumerate}
\item Atomic symbols are S-expressions.
\item If $e_1$ and $e_2$ are S-expressions, so is $(e_1 \cdot e_2)$.
\end{enumerate}
Examples of S-expressions are
\begin{align*}
&AB          \\
&(A \cdot B) \\
&((AB \cdot C) \cdot D)
\end{align*}
An S-expression is then simply an ordered pair, the terms of which may be atomic
symbols or simpler S-expressions. We can represent a list of arbitrary length in
terms of S-expressions as follows. The list
$$ (m_1, m_2, \ldots, m_n) $$
is represented by the S-expression
$$ (m_1 \cdot (m_2 \cdot ( \cdots (m_n \cdot NIL) \cdots ))) $$
Here $NIL$ is an atomic symbol used to terminate lists. Since many of the
symbolic expressions with which we deal are conveniently expressed as lists, we
shall introduce a list notation to
abbreviate\footnote{abbreviate: $verb$ [usually passive] \textit{abbreviate
    something (to something)} to make a word, phrase or name shorter by leaving
  out letters or using only the first letter of each word. $syn$ shorten}
certain S-expressions. We have
\begin{enumerate}
\item $(m)$ stands for $(m \cdot NIL)$.
\item $(m_1, \ldots, m_n)$ stands for
  $(m_1 \cdot ( \cdots (m_n \cdot NIL) \cdots ))$.
\item $(m_1, \ldots, m_n \cdot x)$ stands for
  $(m_1 \cdot ( \cdots (m_n \cdots x) \cdots ))$.
\end{enumerate}

Subexpressions can be similarly abbreviated. Some examples of these
abbreviations are
\begin{center}
  $((AB, C), D)$ for $((AB \cdot (C \cdot NIL)) \cdot (D \cdot NIL))$
\end{center}
\begin{center}
  $((A, B), C, D \cdot E)$ for
  $((A \cdot (B \cdot NIL)) \cdot (C \cdot (D \cdot E)))$
\end{center}

Since we regard the expressions with commas as abbreviations for those not
involving commas, we shall refer to them all as S-expressions.

\paragraph{b.}\textit{Functions of S-expressions and the Expressions That
  Represent Them.}
We now define a class of functions of S-expressions. The expressions
representing these functions are written in a conventional functional
notation. However, in order to clearly distinguish the expressions representing
functions from S-expressions, we shall use sequences of lower-case letters for
function names and variables ranging over the set of S-expressions. We also use
brackets and semicolons, instead of
parentheses\footnote{parenthesis: $noun$ 1. a word, sentence, etc. that is added
  to a speech or piece of writing, especially in order to give extra
  information. In writing, it is separated from the rest of the text using
  brackets, commas or DASHES. 2. (format or NAmE) [usually pl.] either of a pair
  of marks, () placed around extra information in a piece of writing or part of
  a problem in mathematics.}
and commas, for denoting the
application of functions to their arguments. Thus we write
$$ car[x] $$
$$ car[cons[(A \cdot B); x]] $$
In these M-expressions (meta-expressions) any S-expression that occur stand for
themselves.

\paragraph{c.}\textit{The Elementary S-functions and Predicates.}
We introduce the following functions and predicates:
\begin{enumerate}
\item $atom$. $atom[x]$ has the value of $T$ or $F$ according to whether $x$ is
  an atomic symbol. Thus
  $$ atom[X] = T $$
  $$ atom[(X \cdot A)] = F $$
\item $eq$. $eq[x; y]$ is defined if and only if both $x$ and $y$ are
  atomic. $eq[x; y] = T$ if $x$ and $y$ are the same symbol, and $eq[x; y] = F$
  otherwise. Thus
  $$ eq[X; X] = T $$
  $$ eq[X; A] = F $$
  \begin{center}$eq[X; (X \cdot A)]$ is undefined\end{center}
\item $car$. $car[x]$ is defined if and only if $x$ is not atomic. $car[(e_1
  \cdot e_2)] = e_1$. Thus $car[X]$ is undefined.
\item $cdr$. $cdr[x]$ is also defined when $x$ is not atomic. We have $cdr[(e_1
  \cdot e_2)] = e_2$. Thus $cdr[X]$ is undefined.
  $$ cdr[(X \cdot A)] = A \ cdr[((X \cdot A) \cdot Y)] = Y $$
\item $cons$. $cons[x; y]$ is defined for any $x$ and $y$. We have $cons[e_1;
  e_2] = (e_1 \cdot e_2)$. Thus
  $$ cons[X; A] = (X A) $$
  $$ cons[(X \cdot A); Y] = ((X \cdot A) Y) $$
\end{enumerate}
$car$, $cdr$ and $cons$ are easily seen to satisfy the relations
$$ car[cons[x; y]] = x $$
$$ cdr[cons[x; y]] = y $$
\begin{center}$cons[car[x]; cdr[x]] = x$, provided that $x$ is not
  atomic.\end{center}

The names ``car'' and ``cons'' will come to have mnemonic
significance\footnote{significance: $noun$ 1. the importance of something,
  especially when this has an effect on what happens in the future. 2. the
  meaning of something.}
only when
we discuss the representation of the system in the computer. Compositions of
$car$ and $cdr$ give the subexpressions of a given expression in a given
position. Compositions of $cons$ form expressions of a given structure out of
parts. The class of functions which can be formed in this way is quite limited
and not very interesting.

\paragraph{d.}\textit{Recursive S-Functions.}
We get a much larger class of functions (in fact, all computable functions) when
we allow ourselves to form new functions of S-expressions by conditional
expressions and recursive definition. We now give some examples of functions
that are definable in this way.
\begin{enumerate}
\item $ff[x]$. The value of $ff[x]$ is the first atomic symbol of the
  S-expression $x$ with the parentheses ignored. Thus
  $$ ff[((A \cdot B) \cdot C)] = A $$
  We have
  $$ ff[x] = [atom[x] \to x; T \to ff[car[x]]] $$
  We now
  trace\footnote{trace$^*$: $verb$ \textbf{trace somebody/something (to
      something)} to find or discover somebody/something by looking carefully
    for them/it. $syn$ track down}
  in detail the steps in the evaluation of $ff[((A \cdot B) \cdot
    C)]$:
  \begin{align*}
    &\ \ \ \ ff[((A \cdot B) \cdot C)]                                     \\
    &= [atom[((A \cdot B) \cdot C)] \to ((A \cdot B) \cdot C); T \to ff[car[((A
          \cdot B) \cdot C)]]]                                             \\
    &= [F \to ((A \cdot B) \cdot C); T \to ff[car[((A \cdot B) \cdot C)]]] \\
    &= [T \to ff[car[((A \cdot B) \cdot C)]]]                              \\
    &= ff[car[((A \cdot B) \cdot C)]]                                      \\
    &= ff[(A \cdot B)]                                                     \\
    &= [atom[(A \cdot B)] \cdot (A \cdot B); T \to ff[car[(A \cdot B)]]]   \\
    &= [F \to (A \cdot B); T \to ff[car[(A \cdot B)]]]                     \\
    &= [T \to ff[car[(A \cdot B)]]]                                        \\
    &= ff[car[(A \cdot B)]]                                                \\
    &= ff[A]                                                               \\
    &= [atom[A] \to A; T \to ff[car[A]]]                                   \\
    &= [T \to A; T \to ff[car[A]]]                                         \\
    &= A
  \end{align*}
\item $subst[x; y; z]$. This function gives the result of substituting the
  S-expression $x$ for all occurrences of the atomic symbol $y$ in the
  S-expression $z$. It is defined by
  \begin{align*}
    subst[x; y; z] = [atom[z] &\to [eq [z; y] \to x; T \to z];\\
                          T &\to cons[subst[x; y; car[z]]; subst[x; y; cdr[z]]]]
  \end{align*}
  As an example, we have
  $$ subst[(X \cdot A); B; ((A \cdot B) \cdot C)] = ((A \cdot (X \cdot A)) \cdot
  C) $$
\item $equal[x; y]$. This is predicate that has the value $T$ if $x$ and $y$ are
  the same S-expression, and has the value $F$ otherwise. We have
  \begin{align*}
    &\ \ \ \ equal[x; y]                           \\
    &= [atom[x] \land atom[y] \land eq[x; y]]      \\
    &\lor [\lnot atom[x] \land \lnot atom[y] \land \\
    &\ \ \ \ \ equal[car[x]; car[y]] \land         \\
    &\ \ \ \ \ equal[cdr[x]; cdr[y]]]
  \end{align*}
\end{enumerate}

It this convenient to see how the elementary functions look in the abbreviated
list notation. The reader will easily
verify\footnote{verify: $verb$ (formal) to check that something is true or accurate.}
that
\begin{enumerate}[(i)]
\item $car[(m_1, m_2, \ldots, m_n)] = m_1$
\item $cdr[(m_s, m_2, \ldots, m_n)] = (m_2, \ldots, m_n)$
\item $cdr[(m)] = NIL$
\item $cons[m_1; (m_2, \ldots, m_n)] = (m_1, m_2, \ldots, m_n)$
\item $cons[m; NIL] = (m)$
\end{enumerate}

We define
$$ null[x] = atom[x] \land eq[x; NIL] $$
This predicate is useful in dealing with lists.

Compositions of $car$ and $cdr$ arise so frequently that many expressions can be
written more
concisely\footnote{concise: $adj.$ giving only the information that is necessary
  and important, using few words.}
if we abbreviate
$$ cadr[x] \text{ for } car[cdr[x]] $$
$$ caddr[x] \text{ for } car[cdr[cdr[x]]] \text{, etc.} $$

Another useful abbreviation is to write list $[e_1; e_2; \ldots; e_n]$ for\\
{$cons[e_1; cons[e_2; \ldots; cons[e_n; NIL] \cdots ]]$}.

This function gives the list, $(e_1, \ldots, e_n)$, as a function of its
elements.

The following functions are useful when S-expressions are regarded as lists.
\begin{enumerate}
\item $append[x; y]$.
  $$ append[x; y] = [null[x] \to y; T \to cons[car[x]; append[cdr[x]; y]]] $$
  An examples is
  $$ append[(A, B); (C, D, E)] = (A, B, C, D, E) $$
\item $among[x; y]$. This predicate is true if the S-expression $x$ occurs among
  the elements of the list $y$. We have
  $$ among[x; y] =
     \lnot null[y] \land [equal[x; car[y]] \lor among[x; cdr[y]]] $$
\item $pair[x; y]$. This function gives the list of pairs of corresponding
  elements of the list $x$ and $y$. We have
  \begin{align*}
    pair[x; y] = [null[x] \land null[y] &\to NIL;                       \\
      \lnot atom[x] \land \lnot atom[y] &\to cons[list[car[x]; car[y]]; \\
                                &\ \ \ \ \ \ \ \ \ \ \ \ pair[cdr[x]; cdr[y]]]]
  \end{align*}
  An example is
  $$ pair[(A, B, C); (X, (Y, Z), U)] = ((A, X), (B, (Y, Z)), (C, U)) \text{.} $$
\item $assoc[x; y]$. If $y$ is a list of the form $((u_1, v_1), \ldots, (u_n,
  v_n))$ and $x$ is one of the $u$'s, then $assoc[x; y]$ is the corresponding
  $v$. We have
  $$ assoc[x; y] = [eq[caar[y]; x] \to cadar[y]; T \to assoc[x; cdr[y]]] $$
  An example is
  $$ assoc[X; ((W, (A, B)), (X, (C, D)), (Y, (E, F)))] = (C, D) \text{.} $$
\item $sublis[x; y]$. Here $x$ is assumed to have the form of a list of pairs
  $((u_1, v_1), \ldots, (u_n, v_n))$, where the $u$'s are atomic, and $y$ may be
  any S-expression. The value of $sublis[x; y]$ is the result of substituting
  each $v$ for the corresponding $u$ in $y$. In order to define $sublis$, we
  first define an
  auxiliary\footnote{auxiliary: $adj.$ (of workers) giving help or support to
    the main group of workers.}
  function. We have
  \begin{align*}
  sub2[x; z] = [null[x] &\to z;        \\
         eq[caar[x]; z] &\to cadar[x]; \\
                      T &\to sub2[cdr[x]; z]]
  \end{align*}
  \begin{align*}
  sublis[x; y] = [atom[y] &\to sub2[x; y]; \\
                        T &\to cons[sublis[x; car[y]]; sublis[x; cdr[y]]]]
  \end{align*}
  We have
  $$ sublis[((X, (A, B)), (Y, (B, C))); (A, X \cdot Y)] = (A, (A, B), B, C) $$
\end{enumerate}

\paragraph{e.}\textit{Representation of S-Functions by S-Expressions.}

\end{document}
